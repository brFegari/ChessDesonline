<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ChessDesonline — Aulas de Aberturas (Prática)</title>
<style>
:root{
    --light: #f0d9b5; --dark: #b58863; --accent: #2b6cb0; --bg:#222; --good: #2ecc71; --bad:#ff4d4d;
}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:Inter, Arial, Helvetica, sans-serif;background:#151516;color:#eee}
header{background:var(--accent);padding:12px 18px}
header h1{margin:0;font-size:20px}
.app{display:flex;gap:12px;padding:18px;align-items:flex-start}
.sidebar{width:280px;background:var(--bg);border-radius:10px;padding:12px}
.sidebar h2{font-size:16px;margin-bottom:8px}
.openings-list{max-height:360px;overflow:auto;margin-bottom:10px}
/* Itens em estilo "caixa preta" como no original */
.tree-item{display:block;width:100%;text-align:left;margin:6px 0;padding:10px;background:#1b1b1b;color:#fff;border:1px solid #333;border-radius:8px;cursor:pointer;transition:background 0.2s}
.tree-item:hover{background:#262626}
.tree-item.active{background:linear-gradient(90deg,var(--accent),#1c8bd1)}
.tree-label{display:flex;align-items:center;gap:6px;user-select:none}
.tree-arrow{display:inline-block;transition:transform .18s}
.tree-children{display:none;margin-left:12px;margin-top:6px}
.tree-item.expanded>.tree-children{display:block}
.tree-item.expanded>.tree-label>.tree-arrow{transform:rotate(90deg)}

.controls{display:flex;gap:6px;margin-bottom:10px}
.control-btn{flex:1;padding:8px;border-radius:8px;border:none;cursor:pointer;background:linear-gradient(180deg,#2b2b2b,#1a1a1a);color:#fff;font-weight:bold;box-shadow:0 2px 4px rgba(0,0,0,0.4);transition:transform 0.1s, background 0.2s}
.control-btn:hover{background:linear-gradient(180deg,#3c3c3c,#2b2b2b);transform:translateY(-1px)}
.control-btn:active{transform:translateY(1px)}
.nav-btn{flex:unset;padding:8px 12px;border-radius:50%;background:linear-gradient(180deg,#444,#222);box-shadow:0 2px 4px rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;color:#fff}
.nav-btn:hover{background:linear-gradient(180deg,#555,#333)}
.toggle{display:inline-block;padding:8px 10px;border-radius:8px;cursor:pointer;background:#2b2b2b;color:#fff;font-weight:bold}
.info{font-size:13px;color:#ddd}

/* board area */
.board-wrap{display:flex;gap:12px;align-items:flex-start}
#board{width:min(62vw,560px);aspect-ratio:1/1;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);border-radius:10px;overflow:hidden;box-shadow:0 8px 28px rgba(0,0,0,0.6)}
.square{aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;position:relative}
.square.light{background:var(--light)}
.square.dark{background:var(--dark)}
.square.highlight{outline:4px solid rgba(255,255,0,0.25)}
.square.lastmove{box-shadow:inset 0 0 0 4px rgba(0,0,0,0.12)}
.square.correct{outline:5px solid rgba(46,204,113,0.9)}
.square.incorrect{outline:5px solid rgba(255,77,77,0.95)}

/* NOVO */
#board{ position: relative; }
.coord-file, .coord-rank {
position: absolute;
pointer-events: none;
font-size: clamp(10px, 1.6vw, 14px);
color: rgba(90,60,30,0.75); /* marrom suave */
text-shadow: none; /* sem brilho para ficar discreto */
z-index: 2;
font-weight: 500;
letter-spacing: 0.5px;
}
.coord-file { left: 0; right: 0; display: grid; grid-template-columns: repeat(8, 1fr); text-align: center; padding: 2px 6px; }
.coord-file.bottom { bottom: 0; transform: translateY(2px); }
.coord-file.top { top: 0; transform: translateY(-2px); }
.coord-rank { top: 0; bottom: 0; display: grid; grid-template-rows: repeat(8, 1fr); align-items: center; }
.coord-rank.left { left: 0; padding-left: 6px; }
.coord-rank.right { right: 0; padding-right: 6px; text-align: right; }
@media (max-width: 480px) { .coord-file, .coord-rank { font-size: 10px; } }

/* pieces with shape contour */
.piece{width:85%;height:85%;background:none;display:flex;align-items:center;justify-content:center;font-size:clamp(20px,5vw,46px);font-weight:bold}
.piece.w{color:#fff;text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000}
.piece.b{color:#000;text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff}

.rightpanel{width:300px;background:var(--bg);border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:10px}
.movelist{max-height:200px;overflow:auto;font-size:14px;background:#151515;padding:8px;border-radius:6px}
.movelist ol{margin:0;padding-left:20px}
.tips-box{background:#1b1b1b;border-radius:8px;padding:8px;font-size:13px;color:#ccc;flex:1;overflow:auto}
.status-line{margin-top:10px;color:#ddd}
.msg{font-weight:700}

footer{padding:12px;text-align:center;color:#bbb}

/* Layout responsivo */
@media (max-width:1100px){
  .app{flex-direction:column;align-items:center}.sidebar,.rightpanel{width:95%}
}

@media (max-width: 768px) {
  .app {flex-direction: column;padding: 8px}
  .sidebar,.rightpanel {width: 100%;max-width: 100%}
  .board-wrap {flex-direction: column;align-items: center;gap: 16px;width: 100%}
  #board {width: 100%;max-width: 95vw;aspect-ratio: 1 / 1}
  .piece {font-size: clamp(18px, 12vw, 42px)}
  .movelist {max-height: 150px;font-size: 12px}
  .tips-box {font-size: 12px;max-height: 200px}
}
</style>
</head>
<body>
    <header>
        <h1>ChessDesonline — Pratique Aberturas</h1>
    </header>
    <div class="app">
        <aside class="sidebar">
            <h2>Escolha uma abertura</h2>
            <div class="openings-list" id="openingsList"></div>
            <div class="controls">
                <button class="nav-btn" id="btnPrev" title="Voltar">◀</button>
                <button class="control-btn" id="btnPlay" title="Tocar/Pausar">▶</button>
                <button class="nav-btn" id="btnNext" title="Avançar">▶</button>
            </div>
            <div style="margin-top:10px; display:flex; gap:8px">
                <button id="btnReset" class="control-btn" title="Reiniciar posição">Reiniciar</button>
                <div id="btnPractice" class="toggle" title="Ativa/desativa verificação automática" style="background: linear-gradient(90deg,#2b2b2b,#1f7ab8);">Modo Prática: <span id="practiceState">ON</span></div>
            </div>
            <div style="margin-top:10px" class="info">
                <strong>Instruções:</strong>
                <ul style="padding-left:18px; margin:6px 0 0">
                    <li>Clique numa peça para selecioná-la e depois na casa destino.</li>
                    <li>Se o modo "Prática" estiver ON, seus lances serão avaliados frente à abertura escolhida.</li>
                    <li>Errou? o lance será sinalizado em vermelho; acerto em verde.</li>
                </ul>
            </div>
        </aside>

        <main class="board-wrap">
            <div id="board" aria-label="Tabuleiro de xadrez"></div>
            <aside class="rightpanel">
                <div>
                    <h2>Lista de lances</h2>
                    <div class="movelist" id="movelist"><ol id="movesOl"></ol></div>
                </div>
                <div class="tips-box" id="tipsBox">
                    <strong>Dicas da abertura:</strong>
                    <p>Selecione uma abertura para ver dicas estratégicas.</p>
                </div>
                <div class="status-line"><p><strong>Posição:</strong> <span id="status">Brancas a mover</span></p>
                <p class="msg" id="feedback"></p></div>
            </aside>
        </main>
    </div>
    <footer>&copy; Arthur Tschiedel Schnorrenberger</footer>

    <script>
    // ==================
    // 1) Helpers
    // ==================
    const files = ['a','b','c','d','e','f','g','h'];
    const UNICODE = { p:{w:'\u2659',b:'\u265F'}, r:{w:'\u2656',b:'\u265C'}, n:{w:'\u2658',b:'\u265E'}, b:{w:'\u2657',b:'\u265D'}, q:{w:'\u2655',b:'\u265B'}, k:{w:'\u2654',b:'\u265A'} };

    // Caixa de dicas — mapeada por id de abertura
    const tipsData = {
        ruy: "Controle o centro rapidamente e pressione o cavalo em c6 após Bb5.",
        italiana: "Bispo em c4 mira f7; jogue d3 ou c3 para manter o centro estável.",
        siciliana_najdorf: "...a6 controla b5; as brancas miram e4–d4–c4 e ataque no rei.",
        siciliana_classica: "Desenvolva rapidamente e conteste o centro com ...d6 e ...e6/...e5.",
        francesa: "Após e4–e6, prepare d4 e decida entre Avanço, Troca ou Tarrasch.",
        carokann: "Estrutura sólida para as pretas; cuidado com Bc4 contra f7.",
        queens_gambit: "c4 cede um peão para atrair ...dxc4 e ganhar centro com e4.",
        kings_indian: "Pretas fianquetam o bispo e buscam ...e5 ou ...c5 para contragolpe.",
        nimzo: "Pretas cravam Cc3 com ...Bb4, mirando a estrutura de peões das brancas.",
        english: "Controle de casas escuras e flancos; ideias de b3, Bb2, Nc3, g3.",
        petrov: "Simétrico e sólido; tática comum: Nxe5 e Qe2 mirando o cavalo em e5.",
        scotch: "Abertura aberta; trocas rápidas no centro levam a jogo tático.",
        london: "Setup estável com Bf4, e3, c3, h3; ataques no ala do rei com Ne5.",
        catalan: "Fianchetto do bispo em g2; pressão de longo alcance em diagonal h1–a8.",
        kings_gambit: "Sacrifique f2-f4 para abrir as colunas f/e e atacar rápido."
    };

    // ==================
    // 2) Estado do jogo
    // ==================
    let board = {}; // 'e4' -> {type:'p', color:'w'} or null
    let selected = null; let turn = 'w'; let moveHistory = []; let autoplay=null;
    let currentOpening = null; let openingStep = 0; let practiceMode = true;

    const boardEl = document.getElementById('board');
    const movesOl = document.getElementById('movesOl');
    const statusEl = document.getElementById('status');
    const feedbackEl = document.getElementById('feedback');

    function coordToXY(sq){ return {x: files.indexOf(sq[0]), y: parseInt(sq[1]) - 1}; }
    function xyToCoord(x,y){ return files[x] + (y+1); }

    // ==================
    // 3) Tabuleiro
    // ==================
    function createBoardDOM(){
        boardEl.innerHTML = '';
        for(let rank = 8; rank >= 1; rank--){
            for(let f=0; f<8; f++){
                const coord = files[f] + rank;
                const square = document.createElement('div');
                square.className = 'square ' + (((f + rank) % 2 === 0)? 'light':'dark');
                square.dataset.coord = coord;
                square.id = 'sq-' + coord;
                square.addEventListener('click', ()=>onSquareClick(coord));
                boardEl.appendChild(square);
            }
        }
        // === Adiciona sobreposição de coordenadas ===
        const filesLetters=['a','b','c','d','e','f','g','h'];
        const ranksNumbers=[8,7,6,5,4,3,2,1];


        const filesBottom=document.createElement('div');
        filesBottom.className='coord-file bottom';
        filesLetters.forEach(l=>{const s=document.createElement('div');s.textContent=l;filesBottom.appendChild(s);});


        const filesTop=document.createElement('div');
        filesTop.className='coord-file top';
        filesLetters.forEach(l=>{const s=document.createElement('div');s.textContent=l;filesTop.appendChild(s);});


        const ranksLeft=document.createElement('div');
        ranksLeft.className='coord-rank left';
        ranksNumbers.forEach(n=>{const s=document.createElement('div');s.textContent=n;ranksLeft.appendChild(s);});


        const ranksRight=document.createElement('div');
        ranksRight.className='coord-rank right';
        ranksNumbers.forEach(n=>{const s=document.createElement('div');s.textContent=n;ranksRight.appendChild(s);});


        boardEl.appendChild(filesBottom);
        boardEl.appendChild(ranksLeft);
        
    }
        




    function setupInitialPosition(){
        board = {};
        for(let f of files){ for(let r=1;r<=8;r++){ board[f + r] = null; } }
        const placement = {
            'a8':'r','b8':'n','c8':'b','d8':'q','e8':'k','f8':'b','g8':'n','h8':'r',
            'a7':'p','b7':'p','c7':'p','d7':'p','e7':'p','f7':'p','g7':'p','h7':'p',
            'a2':'P','b2':'P','c2':'P','d2':'P','e2':'P','f2':'P','g2':'P','h2':'P',
            'a1':'R','b1':'N','c1':'B','d1':'Q','e1':'K','f1':'B','g1':'N','h1':'R'
        };
        for(const sq in placement){ const ch = placement[sq]; const color = (ch === ch.toUpperCase())? 'w':'b'; board[sq] = { type: ch.toLowerCase(), color }; }

        selected = null; turn='w'; moveHistory=[]; openingStep=0; updateAll();
    }

    function updateAll(){
        for(const sq in board){ const el = document.getElementById('sq-' + sq); if(!el) continue; el.innerHTML=''; el.classList.remove('highlight','lastmove','correct','incorrect'); }
        for(const sq in board){ const p = board[sq]; if(p){ const el = document.getElementById('sq-' + sq); const span = document.createElement('span'); span.className = 'piece ' + p.color; span.textContent = UNICODE[p.type][p.color]; el.appendChild(span); }}
        if(selected){ const sel = document.getElementById('sq-' + selected); if(sel) sel.classList.add('highlight'); }
        if(moveHistory.length>0){ const last = moveHistory[moveHistory.length-1]; document.getElementById('sq-'+last.from).classList.add('lastmove'); document.getElementById('sq-'+last.to).classList.add('lastmove'); }
        renderMoveList(); statusEl.textContent = (turn==='w')? 'Brancas a mover' : 'Pretas a mover';
    }

    // ==================
    // 4) Dicas — FUNÇÃO QUE VOCÊ DEVE CHAMAR AO TROCAR A ABERTURA
    // ==================
    function updateTips(openingId) {
        const tipsBox = document.getElementById('tipsBox');
        tipsBox.innerHTML = `<strong>Dicas da abertura:</strong><p>${tipsData[openingId] || 'Nenhuma dica disponível para esta abertura.'}</p>`;
    }

    // ==================
    // 5) Validação de movimento (inclui roque e en passant)
    // ==================
    function pathClear(from,to){
        const a = coordToXY(from), b = coordToXY(to);
        const dx = Math.sign(b.x - a.x); const dy = Math.sign(b.y - a.y);
        let x = a.x + dx, y = a.y + dy;
        while(x !== b.x || y !== b.y){
            const c = xyToCoord(x,y);
            if(board[c]) return false;
            x += dx; y += dy;
        }
        return true;
    }
    // Função para verificar se o rei da cor especificada está em xeque
    function isKingInCheck(color) {
        let kingPos = null;
        for (let sq in board) {
            if (board[sq] && board[sq].type === 'k' && board[sq].color === color) {
                kingPos = sq;
                break;
            }
        }
        if (!kingPos) return false;
        for (let sq in board) {
            if (board[sq] && board[sq].color !== color) {
                if (originalValidateMove(sq, kingPos)) {
                    return true;
                }
            }
        }
        return false;
    }

    // Guardar a função de validação original (usa hoisting da declaração abaixo)
    const originalValidateMove = validateMove;
    validateMove = function(from, to) {
        const piece = board[from];
        if (!originalValidateMove(from, to)) return false;
        // Não permitir que o rei se mova para uma casa atacada
        if (piece.type === 'k') {
            const backupFrom = board[from];
            const backupTo = board[to];
            board[to] = piece;
            board[from] = null;
            const inCheck = isKingInCheck(piece.color);
            board[from] = backupFrom;
            board[to] = backupTo;
            if (inCheck) return false;
        }
        // Não permitir movimentos que deixem o próprio rei em xeque
        const backupFrom = board[from];
        const backupTo = board[to];
        board[to] = piece;
        board[from] = null;
        const stillInCheck = isKingInCheck(piece.color);
        board[from] = backupFrom;
        board[to] = backupTo;
        if (stillInCheck) return false;
        return true;
    };
    function validateMove(from,to){
        const piece = board[from];
        if(!piece) return false;
        const target = board[to];
        if(target && target.color === piece.color) return false;
        const a = coordToXY(from), b = coordToXY(to);
        const dx = b.x - a.x, dy = b.y - a.y;
        const adx = Math.abs(dx), ady = Math.abs(dy);

        switch(piece.type){
            case 'p':{
                const dir = (piece.color==='w') ? 1 : -1;
                const startRank = (piece.color==='w') ? 1 : 6;
                if(dx===0 && dy===dir && !target) return true;
                if(dx===0 && dy===2*dir && a.y===startRank && !target && !board[xyToCoord(a.x,a.y+dir)]) return true;
                if(adx===1 && dy===dir && target && target.color!==piece.color) return true;
                // en passant
                if(adx===1 && dy===dir && !target){
                    const last = moveHistory[moveHistory.length-1];
                    if(last && last.piece.type==='p' && Math.abs(coordToXY(last.from).y - coordToXY(last.to).y)===2){
                        if(last.to[0] === to[0] && coordToXY(last.to).y === a.y) return true;
                    }
                }
                return false;
            }
            case 'r': return (dx===0 || dy===0) && pathClear(from,to);
            case 'n': return (adx===1 && ady===2) || (adx===2 && ady===1);
            case 'b': return adx===ady && pathClear(from,to);
            case 'q': return (adx===ady || dx===0 || dy===0) && pathClear(from,to);
            case 'k':{
                if(Math.max(adx,ady)===1) return true;
                // roque
                if(piece.color==='w' && from==='e1' && ady===0 && (to==='g1' || to==='c1')){
                    if(to==='g1' && !board['f1'] && !board['g1'] && board['h1']?.type==='r') return true;
                    if(to==='c1' && !board['b1'] && !board['c1'] && !board['d1'] && board['a1']?.type==='r') return true;
                }
                if(piece.color==='b' && from==='e8' && ady===0 && (to==='g8' || to==='c8')){
                    if(to==='g8' && !board['f8'] && !board['g8'] && board['h8']?.type==='r') return true;
                    if(to==='c8' && !board['b8'] && !board['c8'] && !board['d8'] && board['a8']?.type==='r') return true;
                }
                return false;
            }
            default: return false;
        }
    }

    function executeMove(from,to,record=true){
        const piece = board[from];
        if(!piece) return false;
        const captured = board[to] || null;

        // en passant (captura)
        if(piece.type==='p' && to[0]!==from[0] && !captured){
            const dir = (piece.color==='w')? -1 : 1;
            const capSq = to[0] + (parseInt(to[1])+dir);
            board[capSq] = null;
        }
        // roque (mover torre)
        if(piece.type==='k' && Math.abs(coordToXY(from).x - coordToXY(to).x)===2){
            if(to==='g1'){ board['f1'] = board['h1']; board['h1'] = null; }
            if(to==='c1'){ board['d1'] = board['a1']; board['a1'] = null; }
            if(to==='g8'){ board['f8'] = board['h8']; board['h8'] = null; }
            if(to==='c8'){ board['d8'] = board['a8']; board['a8'] = null; }
        }

        board[to] = piece;
        board[from] = null;
        if(record) moveHistory.push({from,to,piece,captured});
        turn = (turn==='w')? 'b':'w';
        updateAll();
        return true;
    }

    function undoMove(){
        if(moveHistory.length===0) return;
        const last = moveHistory.pop();
        board[last.from] = last.piece;
        board[last.to] = last.captured;
        turn = last.piece.color; if(openingStep>0) openingStep--; updateAll();
    }

    function tryUserMove(from,to){
        const piece = board[from]; if(!piece) return false;
        if(practiceMode && currentOpening){
            if(openingStep >= currentOpening.moves.length){ showFeedback('A abertura já terminou', 'info'); return false; }
            const expected = currentOpening.moves[openingStep];
            const expectedStr = expected.trim();
            const attempt = `${from}-${to}`;
            const expectedSide = (openingStep % 2 === 0) ? 'w' : 'b';
            if(piece.color !== expectedSide){ showFeedback('Não é a vez dessa cor nesse passo da abertura', 'bad'); flashSquares([from,to],'incorrect'); return false; }
            if(attempt === expectedStr){
                if(!validateMove(from,to)){ showFeedback('Movimento inválido pelas regras do xadrez', 'bad'); flashSquares([from,to],'incorrect'); return false; }
                executeMove(from,to,true); openingStep++; showFeedback('Correto!', 'good'); flashSquares([to],'correct');
                return true;
            } else {
                showFeedback(`Errado — o lance esperado é ${expectedStr}`, 'bad'); flashSquares([from,to],'incorrect'); return false;
            }
        } else {
            if(!validateMove(from,to)){ showFeedback('Movimento inválido', 'bad'); flashSquares([from,to],'incorrect'); return false; }
            executeMove(from,to,true); showFeedback('Lance efetuado (modo livre)', 'info'); return true;
        }
    }

    function onSquareClick(coord){
        const piece = board[coord];
        if(selected){
            if(selected === coord){ selected=null; updateAll(); return; }
            const ok = tryUserMove(selected, coord);
            selected = null; updateAll();
            return;
        } else {
            if(piece && piece.color === turn){ selected = coord; updateAll(); }
        }
    }

    function flashSquares(coords, cls){
        coords.forEach(c=>{ const el = document.getElementById('sq-'+c); if(el) el.classList.add(cls); });
        setTimeout(()=>{ coords.forEach(c=>{ const el = document.getElementById('sq-'+c); if(el) el.classList.remove(cls); }); }, 700);
    }

    function showFeedback(text, type){
        feedbackEl.textContent = text;
        feedbackEl.style.color = (type==='good')? 'var(--good)' : (type==='bad')? 'var(--bad)' : '#ddd';
        setTimeout(()=>{ feedbackEl.textContent=''; }, 2200);
    }

    // ==================
    // 6) Lista de lances (duas jogadas por linha)
    // ==================
    function renderMoveList(){
        movesOl.innerHTML='';
        for(let i=0;i<moveHistory.length;i+=2){
            const li = document.createElement('li');
            const w = moveHistory[i] ? (moveHistory[i].from + '-' + moveHistory[i].to) : '';
            const b = moveHistory[i+1] ? (moveHistory[i+1].from + '-' + moveHistory[i+1].to) : '';
            li.textContent = w + (b ? ' ' + b : '');
            movesOl.appendChild(li);
        }
    }

    // ==================
    // 7) Banco de aberturas (array original)
    // ==================
    const OPENINGS = [
        {id:'ruy', name:'Ruy Lopez (Espanhola)', moves:['e2-e4','e7-e5','g1-f3','b8-c6','f1-b5','a7-a6','b5-a4','g8-f6']},
        {id:'italiana', name:'Abertura Italiana', moves:['e2-e4','e7-e5','g1-f3','b8-c6','f1-c4','g8-f6']},
        {id:'siciliana_najdorf', name:'Siciliana (Najdorf)', moves:['e2-e4','c7-c5','g1-f3','d7-d6','d2-d4','c5-d4','f3-d4']},
        {id:'siciliana_classica', name:'Siciliana (Clássica)', moves:['e2-e4','c7-c5','g1-f3','d7-d6','d2-d4','c5-d4','f3-d4','g8-f6']},
        {id:'francesa', name:'Francesa', moves:['e2-e4','e7-e6','d2-d4','d7-d5','e4-d5','e6-d5']},
        {id:'carokann', name:'Caro-Kann', moves:['e2-e4','c7-c6','d2-d4','d7-d5','e4-d5','c6-d5']},
        {id:'queens_gambit', name:"Queen's Gambit", moves:['d2-d4','d7-d5','c2-c4','e7-e6','b1-c3']},
        {id:'kings_indian', name:"King's Indian", moves:['d2-d4','g8-f6','c2-c4','g7-g6','g1-f3','f8-g7']},
        {id:'nimzo', name:'Nimzo-Indian', moves:['d2-d4','g8-f6','c2-c4','e7-e6','b1-c3','f8-b4']},
        {id:'english', name:'English Opening', moves:['c2-c4','e7-e5','g2-g3','d7-d5','b1-c3']},
        {id:'petrov', name:'Petroff (Defesa Russa)', moves:['e2-e4','e7-e5','g1-f3','g8-f6']},
        {id:'scotch', name:'Scotch Game', moves:['e2-e4','e7-e5','g1-f3','b8-c6','d2-d4','e5-d4']},
        {id:'london', name:'London System', moves:['d2-d4','g8-f6','c2-c3','e7-e6','b1-d2']},
        {id:'catalan', name:'Catalan', moves:['d2-d4','g8-f6','c2-c4','e7-e6','g2-g3','d7-d5']}
    ];

    // Mapa id -> índice (para conectar árvore ao array existente)
    const OPENING_INDEX = OPENINGS.reduce((acc,op,idx)=>{ acc[op.id]=idx; return acc; },{});

    // ==================
    // 8) Sidebar hierárquica (3 níveis com setas)
    // ==================
    const OPENINGS_TREE = [
      {label:'Aberturas de peão do rei', children:[
        {label:'Abertas', children:[{id:'ruy'},{id:'italiana'},{id:'scotch'},{id:'petrov'}]},
        {label:'Semi-abertas', children:[{id:'siciliana_najdorf'},{id:'siciliana_classica'},{id:'francesa'},{id:'carokann'}]},
        {label:'Agressivas', children:[{id:'kings_gambit'}]}
      ]},
      {label:'Aberturas de peão da rainha', children:[
        {label:'Clássicas', children:[{id:'queens_gambit'},{id:'catalan'},{id:'london'}]},
        {label:'Defesas', children:[{id:'kings_indian'},{id:'nimzo'}]}
      ]},
      {label:'Aberturas diferentes', children:[{id:'english'}]}
    ];

    function renderTree(container, data){
      data.forEach(node=>{
        const item = document.createElement('div');
        item.className = 'tree-item';
        const label = document.createElement('div');
        label.className = 'tree-label';

        if(node.children){
          const arrow = document.createElement('span');
          arrow.className = 'tree-arrow';
          arrow.textContent = '▶';
          label.appendChild(arrow);
          const text = document.createElement('span');
          text.textContent = node.label;
          label.appendChild(text);
          item.appendChild(label);

          const children = document.createElement('div');
          children.className = 'tree-children';
          renderTree(children, node.children);
          item.appendChild(children);

          label.addEventListener('click', ()=>{
            item.classList.toggle('expanded');
          });
        } else {
          const text = document.createElement('span');
          const op = OPENINGS[OPENING_INDEX[node.id]];
          text.textContent = op ? op.name : node.id;
          label.appendChild(text);
          item.appendChild(label);
          item.dataset.openingId = node.id;
          label.addEventListener('click', ()=>{
            document.querySelectorAll('.openings-list .tree-item').forEach(el=>el.classList.remove('active'));
             document.querySelectorAll('.openings-list .tree-item').forEach(el => el.style.background = ""); // limpa fundo
            item.style.background = "var(--accent)"; // aplica cor
            item.classList.add('active');
            selectOpeningById(node.id);
          });
        }
        container.appendChild(item);

      });
    }

    // Função antiga de seleção por índice — mantida e usada internamente
    function selectOpening(idx){
        const listEls = document.querySelectorAll('#openingsList .tree-item');
        listEls.forEach(b=>b.classList.remove('active'));
        currentOpening = OPENINGS[idx]; openingStep = 0; setupInitialPosition(); renderOpeningPreview();
        updateTips(currentOpening.id);
        showFeedback(`Abertura selecionada: ${currentOpening.name}`,'info');
    }

    // Nova função: seleciona usando id via mapa, preservando a experiência original
    function selectOpeningById(id){
        const idx = OPENING_INDEX[id];
        if(idx===undefined){ showFeedback('Abertura não encontrada', 'bad'); return; }
        selectOpening(idx);
    }

    function renderOpeningPreview(){
        movesOl.innerHTML = '';
        if(!currentOpening) return;
        const lines = Math.ceil(currentOpening.moves.length/2);
        for(let i=0;i<lines;i++){ const li = document.createElement('li'); li.textContent = ''; movesOl.appendChild(li); }
    }

    // ==================
    // 9) Controles
    // ==================
    function stepForward(){
        if(!currentOpening || openingStep>=currentOpening.moves.length) return;
        const mv = currentOpening.moves[openingStep]; const [from,to] = mv.split('-');
        turn = (openingStep%2===0)? 'w':'b';
        if(!validateMove(from,to)){ console.warn('Movimento inválido (stepForward)', mv); return; }
        executeMove(from,to,true); openingStep++; showFeedback('Lance da abertura executado','info');
    }

    function stepBack(){ undoMove(); }

    function playOpening(){
        if(!currentOpening) return;
        if(autoplay){ clearInterval(autoplay); autoplay=null; document.getElementById('btnPlay').textContent='▶'; return; }
        document.getElementById('btnPlay').textContent='❚❚';
        autoplay = setInterval(()=>{
            if(!currentOpening || openingStep>=currentOpening.moves.length){ clearInterval(autoplay); autoplay=null; document.getElementById('btnPlay').textContent='▶'; return; }
            stepForward();
        }, 700);
    }

    function resetPosition(){ setupInitialPosition(); openingStep=0; showFeedback('Posição reiniciada','info'); }

    document.getElementById('btnPrev').addEventListener('click', stepBack);
    document.getElementById('btnNext').addEventListener('click', stepForward);
    document.getElementById('btnPlay').addEventListener('click', playOpening);
    document.getElementById('btnReset').addEventListener('click', resetPosition);

    const btnPractice = document.getElementById('btnPractice'); const practiceState = document.getElementById('practiceState');
    btnPractice.addEventListener('click', ()=>{ practiceMode = !practiceMode; practiceState.textContent = practiceMode ? 'ON' : 'OFF'; btnPractice.style.background = practiceMode ? 'linear-gradient(90deg,#2b2b2b,#1f7ab8)' : '#2b2b2b'; showFeedback('Modo prática: ' + (practiceMode?'ON':'OFF'),'info'); });

    // ==================
    // 10) Inicialização
    // ==================
    createBoardDOM();
    // Renderiza árvore hierárquica no lugar da lista plana
    renderTree(document.getElementById('openingsList'), OPENINGS_TREE);
    setupInitialPosition();
    // Seleciona uma abertura padrão (pode trocar ou remover)
    selectOpeningById('ruy');

    </script>
</body>
</html>
